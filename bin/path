#!/usr/bin/env ruby
$LOAD_PATH.unshift File.expand_path("../../lib", __FILE__)
require "path"
require 'ray'
require 'pry'
require "ext/array"

class Map < Array
  def initialize(width, height)
    super(width) do
      Array.new(height) do
        rand > 0.20 ? true : false
      end
    end
  end

  def width
    size
  end

  def height
    first.size
  end
end

class Game
  attr_accessor :start, :finish

  def size
    10
  end

  def width
    80
  end

  def height
    60
  end

  def map
    @map ||= Map.new(width, width)
  end

  def pos_to_node(pos)
    x = (pos.x / size).to_i
    y = (pos.y / size).to_i
    map.to_nodes[x][y]
  end

  def path
    @path ||= Path::Node.df_search start, finish, method(:heuristic)
  end

  def cursor
    @cursor ||= Ray::Polygon.rectangle([-10, -10, size, size], Ray::Color.white)
    @cursor.each { |point| point.color = !start ? Ray::Color.green : Ray::Color.red }
    @cursor
  end

  def pos_to_grid(pos)
    Ray::Vector2.new(
      pos.x - (pos.x % size),
      pos.y - (pos.y % size)
    )
  end

  def heuristic(to, from)
    x = to.data[:x] - from.data[:x]
    y = to.data[:y] - from.data[:y]

    Math.sqrt(x ** 2 + y ** 2)
  end

  def map_to_sprite
    if start and finish
      path.each do |node, value|
        x, y = node.data[:x], node.data[:y]
        map[x][y] = value
      end

      self.start = nil
      self.finish = nil
    end

    image = Ray::Image.new [width * size, height * size]

    Ray::ImageTarget.new(image) do |target|
      map.transpose.each.with_index.map do |row, y|
        row.each_with_index.map do |column, x|
          color = case column
          when Numeric
            Ray::Color.new(column, column, column)
          when true
            Ray::Color.white
          when false
            Ray::Color.black
          end

          target.draw(Ray::Polygon.rectangle([x * size, y * size, 1 * size, 1 * size], color))
        end
      end

      target.update
    end

    Ray::Sprite.new(image, at: [0, 0])
  end
end




Ray.game "Test" do
  register { add_hook :quit, method(:exit!) }

  scene :map do
    @helper = Game.new

    on :mouse_press do |button, pos|
      if !@helper.start
        puts "start"
        puts "#{@helper.pos_to_node(pos)}"
        @helper.start = @helper.pos_to_node(pos)
      else
        puts "finish"
        puts "#{@helper.pos_to_node(pos)}"
        @helper.finish = @helper.pos_to_node(pos)
      end

      @cache = nil if @helper.start and @helper.finish
    end
    on :mouse_motion do |pos|
      @helper.cursor.pos = @helper.pos_to_grid(pos)
    end

    render do |win|
      win.draw  @cache ||= begin
        @helper.map_to_sprite
      end

      win.draw @helper.cursor
    end
  end

  scenes << :map
end

=begin

Dispel::Screen.open do |screen|
  infinity = 1.0 / 0.0
  width  = 5
  map    = Map.new(screen.columns / width, screen.lines - 3)
  log    = String.new
  help = "arrows: move s: place start f: place finish t: toggle open/closed\nCtrl+c: exit"
  start_x, start_y, finish_x, finish_y = nil
  drawable = [
    map,
    help,
    log
  ]

  screen.draw drawable.map(&:to_s).join("\n")

  Dispel::Keyboard.output do |key|
    case key
    when :"Ctrl+c"
      break
    when :up
      map.cursor_y -= 1
    when :down
      map.cursor_y += 1
    when :right
      map.cursor_x += 1
    when :left
      map.cursor_x -= 1
    when "t"
      x, y = map.cursor_x, map.cursor_y
      map[x][y] = !map[x][y]
    when "f"
      finish_x, finish_y = map.cursor_x, map.cursor_y
    when "s"
      start_x, start_y = map.cursor_x, map.cursor_y
    end

    if start_x && start_y && finish_x && finish_y
      nodes   = map.to_nodes
      start   = nodes[start_x][start_y]
      finish  = nodes[finish_x][finish_y]
      visited = {}

      heuristic = lambda do |to, from|
        x = to.data[:x] - from.data[:x]
        y = to.data[:y] - from.data[:y]

        Math.sqrt(x ** 2 + y ** 2)
      end

      distances = Path::Node.df_search start, finish, heuristic

      distances.each do |node, value|
        x, y = node.data[:x], node.data[:y]
        map[x][y] = value
      end

      while(start != finish) do
        x, y = start.data[:x], start.data[:y]
        map[x][y] = " . "

        start = start.neighbors.min do |a, b|
          a = distances[a] || infinity
          b = distances[b] || infinity

          a <=> b
        end
      end
    end

    screen.draw drawable.map(&:to_s).join("\n")
  end
end

=end

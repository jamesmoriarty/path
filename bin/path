#!/usr/bin/env ruby
$LOAD_PATH.unshift File.expand_path("../../lib", __FILE__)
require "path"
require "ext/array"

class Map < Array
  def initialize(width, height)
    super(width) do
      Array.new(height) do
        rand > 0.10 ? true : false
      end
    end
  end

  def width
    size
  end

  def height
    first.size
  end
end

require 'ray'

def size
  10
end

def width
  80
end

def height
  60
end

def pos_to_grid(pos)
  Ray::Vector2.new(
    pos.x - (pos.x % size),
    pos.y - (pos.y % size)
  )
end

def map_to_sprite(map)
  image = Ray::Image.new [width * size, height * size]

  Ray::ImageTarget.new(image) do |target|
    map.transpose.each.with_index.map do |row, y|
      row.each_with_index.map do |column, x|
        color = column ? Ray::Color.white : Ray::Color.black
        target.draw(Ray::Polygon.rectangle([x * size, y * size, 1 * size, 1 * size], color))
      end
    end

    target.update
  end

  Ray::Sprite.new(image, at: [0, 0])
end

Ray.game "Test" do
  register { add_hook :quit, method(:exit!) }

  scene :map do
    @cursor = Ray::Polygon.rectangle([-10, -10, size, size], Ray::Color.red)
    @map    = Map.new(width, width)

    on :mouse_motion do |pos|
      @cursor.pos = pos_to_grid(pos)
    end

    render do |win|
      win.draw @cache ||= begin
        map_to_sprite(@map)
      end

      win.draw @cursor
    end
  end

  scenes << :map
end

=begin

Dispel::Screen.open do |screen|
  infinity = 1.0 / 0.0
  width  = 5
  map    = Map.new(screen.columns / width, screen.lines - 3)
  log    = String.new
  help = "arrows: move s: place start f: place finish t: toggle open/closed\nCtrl+c: exit"
  start_x, start_y, finish_x, finish_y = nil
  drawable = [
    map,
    help,
    log
  ]

  screen.draw drawable.map(&:to_s).join("\n")

  Dispel::Keyboard.output do |key|
    case key
    when :"Ctrl+c"
      break
    when :up
      map.cursor_y -= 1
    when :down
      map.cursor_y += 1
    when :right
      map.cursor_x += 1
    when :left
      map.cursor_x -= 1
    when "t"
      x, y = map.cursor_x, map.cursor_y
      map[x][y] = !map[x][y]
    when "f"
      finish_x, finish_y = map.cursor_x, map.cursor_y
    when "s"
      start_x, start_y = map.cursor_x, map.cursor_y
    end

    if start_x && start_y && finish_x && finish_y
      nodes   = map.to_nodes
      start   = nodes[start_x][start_y]
      finish  = nodes[finish_x][finish_y]
      visited = {}

      heuristic = lambda do |to, from|
        x = to.data[:x] - from.data[:x]
        y = to.data[:y] - from.data[:y]

        Math.sqrt(x ** 2 + y ** 2)
      end

      distances = Path::Node.df_search start, finish, heuristic

      distances.each do |node, value|
        x, y = node.data[:x], node.data[:y]
        map[x][y] = value
      end

      while(start != finish) do
        x, y = start.data[:x], start.data[:y]
        map[x][y] = " . "

        start = start.neighbors.min do |a, b|
          a = distances[a] || infinity
          b = distances[b] || infinity

          a <=> b
        end
      end
    end

    screen.draw drawable.map(&:to_s).join("\n")
  end
end

=end
